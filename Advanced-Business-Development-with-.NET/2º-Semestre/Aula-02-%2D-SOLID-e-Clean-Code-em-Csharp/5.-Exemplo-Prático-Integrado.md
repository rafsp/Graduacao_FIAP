[[_TOC_]]

Nesta seção, vamos trabalhar com um cenário de **sistema de pedidos** que precisa calcular descontos, salvar no banco e enviar uma confirmação por e-mail.
    
O código inicial está funcional, mas viola vários princípios **SOLID** e práticas de **Clean Code**.  
O objetivo é **refatorar** o código para torná-lo mais modular, legível e fácil de manter.
    
#Cenário inicial – Código "funcional, mas problemático"
    
```csharp
public class PedidoService
{
    public void ProcessarPedido(Pedido pedido)
    {
        // Validação
        if (pedido.Itens.Count == 0)
            throw new Exception("Pedido sem itens");

        // Cálculo de desconto
        if (pedido.Cliente.Tipo == "VIP")
        {
            pedido.Desconto = pedido.Total * 0.1m;
        }
        else if (pedido.Cliente.Tipo == "NOVO")
        {
            pedido.Desconto = pedido.Total * 0.05m;
        }

         // Persistência
        using (var conn = new SqlConnection("Server=.;Database=Pedidos;Trusted_Connection=True;"))
        {
            conn.Open();
            var cmd = conn.CreateCommand();
            cmd.CommandText = $"INSERT INTO Pedido (ClienteId, Total, Desconto) VALUES ({pedido.Cliente.Id}, {pedido.Total}, {pedido.Desconto})";
            cmd.ExecuteNonQuery();
        }
    
        // Envio de e-mail
        var smtp = new SmtpClient("smtp.empresa.com");
        smtp.Send("loja@empresa.com", pedido.Cliente.Email, "Pedido confirmado", "Seu pedido foi processado com sucesso!");
    }
}
```

# Problemas identificados

1.  **Violação do SRP**:  
    `PedidoService` faz **validação**, **cálculo de desconto**, **persistência** e **envio de e-mail**.
    
2.  **Violação do OCP**:  
    Para adicionar um novo tipo de desconto, é necessário alterar a lógica interna da classe.
    
3.  **Violação do DIP**:  
    Dependência direta de `SqlConnection` e `SmtpClient`.
    
4.  **Clean Code**:
    *   Métodos grandes e misturados.
        
    *   Nomes pouco descritivos.
        
    *   Strings de conexão e parâmetros fixos no código (hardcoded).

# Estratégia de refatoração

*   Extrair cada responsabilidade para uma classe específica (SRP).
*   Utilizar interfaces para permitir extensão sem modificação (OCP).
*   Injetar dependências via construtor (DIP).
*   Melhorar nomes e reduzir complexidade (Clean Code).    
*   Tornar o código testável e modular.

# Refatoração passo a passo

## Criando interfaces para abstração
```csharp
public interface IValidadorPedido
{
    void Validar(Pedido pedido);
}
    
public interface ICalculadoraDesconto
{
    decimal Calcular(Pedido pedido);
}
    
public interface IRepositorioPedido
{
    void Salvar(Pedido pedido);
}
    
public interface INotificadorCliente
{
    void Notificar(Pedido pedido);
} 
```

## Implementações separadas por responsabilidade

### Validação
```csharp
public class ValidadorPedido : IValidadorPedido
{
    public void Validar(Pedido pedido)
    {
        if (pedido.Itens.Count == 0)
            throw new InvalidOperationException("Pedido sem itens");
    }
}
```    

### Cálculo de desconto
```csharp
public class CalculadoraDescontoVip : ICalculadoraDesconto
{
    public decimal Calcular(Pedido pedido) => pedido.Total * 0.1m;
}
    
public class CalculadoraDescontoNovoCliente : ICalculadoraDesconto
{
    public decimal Calcular(Pedido pedido) => pedido.Total * 0.05m;
}
```    

### Persistência
```csharp
public class RepositorioPedido : IRepositorioPedido
{
    private readonly string _connectionString;

    public RepositorioPedido(string connectionString)
    {
        _connectionString = connectionString;
    }
 
    public void Salvar(Pedido pedido)
    {
        using var conn = new SqlConnection(_connectionString);
        conn.Open();
        var cmd = conn.CreateCommand();
        cmd.CommandText = "INSERT INTO Pedido (ClienteId, Total, Desconto) VALUES (@clienteId, @total, @desconto)";
        cmd.Parameters.AddWithValue("@clienteId", pedido.Cliente.Id);
        cmd.Parameters.AddWithValue("@total", pedido.Total);
        cmd.Parameters.AddWithValue("@desconto", pedido.Desconto);
        cmd.ExecuteNonQuery();
    }
}
```    

### Notificação
```csharp
public class NotificadorEmail : INotificadorCliente
{
    private readonly string _smtpHost;

    public NotificadorEmail(string smtpHost)
    {
        _smtpHost = smtpHost;
    }

    public void Notificar(Pedido pedido)
    {
        using var smtp = new SmtpClient(_smtpHost);
        smtp.Send("loja@empresa.com", pedido.Cliente.Email, "Pedido confirmado", "Seu pedido foi processado!");
    }
}
```

### Classe de orquestração (Aplicando DIP)
```csharp
public class PedidoService
{
    private readonly IValidadorPedido _validador;
    private readonly ICalculadoraDesconto _calculadora;
    private readonly IRepositorioPedido _repositorio;
    private readonly INotificadorCliente _notificador;

    public PedidoService(
        IValidadorPedido validador,
        ICalculadoraDesconto calculadora,
        IRepositorioPedido repositorio,
        INotificadorCliente notificador)
    {
        _validador = validador;
        _calculadora = calculadora;
        _repositorio = repositorio;
        _notificador = notificador;
    }

    public void ProcessarPedido(Pedido pedido)
    {
        _validador.Validar(pedido);
        pedido.Desconto = _calculadora.Calcular(pedido);
        _repositorio.Salvar(pedido);
        _notificador.Notificar(pedido);
    }
}
```    

# Benefícios alcançados

*   **SRP**: Cada classe tem uma única responsabilidade.
*   **OCP**: Novos tipos de desconto podem ser adicionados criando novas classes que implementam `ICalculadoraDesconto`.
*   **DIP**: `PedidoService` depende apenas de abstrações.
*   **Clean Code**: Código mais legível, modular e testável.
*   **Testabilidade**: Fácil criar _mocks_ para testes unitários.

# Design simplificado da solução
```plaintext
    [PedidoService]
       |--- IValidadorPedido -> ValidadorPedido
       |--- ICalculadoraDesconto -> CalculadoraDescontoVip / CalculadoraDescontoNovoCliente
       |--- IRepositorioPedido -> RepositorioPedido
       |--- INotificadorCliente -> NotificadorEmail
```

# Passos futuros que seriam previstos

*   Implementar testes unitários para cada componente isoladamente.
    
*   Introduzir _Dependency Injection_ nativo do ASP.NET Core (`IServiceCollection`).
    
*   Substituir acesso direto a SQL com o **Entity Framework Core**.
    
*   Externalizar strings de configuração (`appsettings.json`).