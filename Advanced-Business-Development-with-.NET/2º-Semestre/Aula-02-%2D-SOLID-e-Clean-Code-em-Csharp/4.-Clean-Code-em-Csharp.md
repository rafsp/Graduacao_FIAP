[[_TOC_]]
    
O conceito de **Clean Code** (código limpo) vai além de escrever um código que apenas funcione.  
Significa escrever código **claro, legível, de fácil manutenção e com baixo acoplamento**, facilitando a colaboração entre desenvolvedores.
    
Robert C. Martin, em seu livro *Clean Code: A Handbook of Agile Software Craftsmanship*, define que código limpo deve ser:
- Fácil de ler.
- Fácil de entender.
- Fácil de modificar.
- Testável.
- Livre de duplicações desnecessárias.
    
# Código Legível
    
## Nomes claros
Um bom nome deve indicar claramente o propósito de uma variável, método ou classe.
    
**Ruim:**
```csharp
public class Calc
{
    public double DoIt(double a, double b)
    {
        return a * b * 0.05;
    }
}
```
    
**Bom:**
```csharp
public class CalculadoraImposto
{
    public double CalcularICMS(double valorBase, double aliquota)
    {
        return valorBase * aliquota;
    }
}
```    

## Dicas
*   Evite abreviações obscuras.
    
*   Prefira nomes descritivos a nomes curtos.
    
*   Nomes de métodos devem ser verbos (`Calcular`, `Obter`, `Enviar`).
    
*   Nomes de classes devem ser substantivos (`Pedido`, `Cliente`, `RelatorioGenerator`).

# Funções Pequenas e Coesas

Cada função deve fazer **apenas uma coisa** (coerente com o SRP).  
Funções pequenas:
*   São mais fáceis de entender.
    
*   São mais fáceis de testar.
    
*   Têm menos chance de introduzir bugs.
    
**Ruim:**
```csharp
public void ProcessarPedido(Pedido pedido)
{
    // Validar
    if (pedido.Itens.Count == 0) throw new Exception("Pedido vazio");
    
    // Calcular desconto
    if (pedido.Cliente.Tipo == "VIP")
        pedido.Desconto = pedido.Total * 0.1m;

    // Salvar no banco
    using var conn = new SqlConnection("...");
    conn.Open();
    // Insert...

    // Enviar e-mail
    var smtp = new SmtpClient("...");
    smtp.Send("loja@teste.com", pedido.Cliente.Email, "Pedido recebido", "Detalhes...");
}
```
    
**Bom:**
```csharp
public void ProcessarPedido(Pedido pedido)
{
    ValidarPedido(pedido);
    CalcularDesconto(pedido);
    SalvarPedido(pedido);
    EnviarConfirmacao(pedido);
}
```    

Agora cada método é **pequeno, focado e fácil de ler**.

# Tratamento de Erros

Erros devem ser tratados de forma clara e previsível, sem esconder informações importantes.

**Ruim:**

```csharp
try
{
    // Código
}
catch
{
    // Silencia erro (péssima prática)
}
```    

**Bom:**
```csharp
try
{
    _pedidoRepository.Salvar(pedido);
}
catch (SqlException ex)
{
    _logger.LogError(ex, "Erro ao salvar pedido no banco.");
    throw new PedidoException("Não foi possível processar o pedido.", ex);
}
```   

## Boas práticas
*   Não engula exceções silenciosamente.
*   Use exceções específicas.
*   Forneça mensagens claras.
*   Mantenha logs úteis para diagnóstico.

# Redução de Complexidade

Código com muitos aninhamentos (_nested ifs_, _loops_ dentro de _loops_) dificulta a leitura e aumenta o risco de erros.

## Evitar aninhamentos profundos

**Ruim:**
```csharp
if (usuario != null)
{
    if (usuario.Ativo)
    {
        if (usuario.Permissao == "Admin")
        {
            ExecutarAcao();
        }
    }
}
```    

**Bom:**

```csharp
if (usuario == null) return;
if (!usuario.Ativo) return;
if (usuario.Permissao != "Admin") return;

ExecutarAcao();
```    

Esse padrão é conhecido como **early return** e melhora a legibilidade.

# Comentários

## Quando usar

Comentários são úteis para:
*   Explicar regras de negócio complexas. 
*   Justificar decisões de design.
*   Documentar partes não óbvias do código.
    
## Quando evitar

Comentários não devem:
*   Explicar algo que o próprio código poderia deixar claro.
    
*   Ser usados para compensar nomes ruins de variáveis ou métodos.
    
*   Ficar desatualizados (comentário divergente é pior que nenhum comentário).
    
**Ruim:**

```csharp
// Incrementa i em 1
i = i + 1;
```   

**Bom:**
```csharp
// Ajusta o preço considerando a inflação acumulada do período
precoAjustado = precoBase * indiceInflacao;
```    

# Eliminação de Código Morto

Código não utilizado aumenta o tamanho do sistema, gera confusão e pode induzir a erros.
## Boas práticas
*   Remova métodos, variáveis e classes não usados.
    
*   Utilize `git` para histórico: não há motivo para manter código comentado.

# Duplicação de Código

Duplicações violam o **DRY** (_Don't Repeat Yourself_).  
Sempre que encontrar código duplicado:
*   Extraia para um método comum.
    
*   Centralize a lógica em um único ponto.
    
**Ruim:**
```csharp
decimal CalcularDescontoVip(decimal valor) => valor * 0.1m;
decimal CalcularDescontoClienteNovo(decimal valor) => valor * 0.05m;
```
**Bom:**
```csharp
decimal CalcularDesconto(decimal valor, decimal percentual) => valor * percentual;
```

# Check-list prático de Clean Code

Antes de dar _commit_:
1.  Os nomes são claros e descritivos?
2.  As funções são curtas e coesas?
3.  Há tratamento de erros adequado?
4.  Evitei aninhamentos desnecessários?
5.  Os comentários são realmente úteis?
6.  Removi código morto ou duplicado?
7.  O código está formatado e consistente?

# Resumo

Escrever **Clean Code** não é um evento único, mas um processo contínuo.  
Assim como **SOLID** ajuda no design de sistemas, **Clean Code** garante que o código do dia a dia seja fácil de entender e evoluir.
Na próxima seção, vamos unir SOLID e Clean Code em um **exemplo prático integrado**, mostrando como refatorar um sistema legado passo a passo.