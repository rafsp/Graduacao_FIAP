[[_TOC_]]

O acrônimo **SOLID** representa cinco princípios que ajudam a criar sistemas **modulares**, **flexíveis** e **fáceis de manter**.  
Eles são um conjunto de **boas práticas de design de software orientado a objetos**.
    
# S - Single Responsibility Principle (SRP)
    
## Definição
> "Uma classe deve ter **apenas um motivo** para mudar." — Robert C. Martin
    
O SRP prega que cada classe, método ou módulo deve ter **uma única responsabilidade** bem definida.  
Isso reduz a complexidade e facilita manutenção e testes.
    
## Problema comum
Classes que acumulam múltiplas funções (conhecidas como **God Classes**), tornando-se difíceis de entender e modificar.
    
## Exemplo ruim
    
```csharp
public class RelatorioService
{
    public void GerarRelatorio()
    {
        // Lógica de geração
    }
    
    public void SalvarRelatorio()
    {
        // Lógica de persistência
    }
    
    public void EnviarRelatorioPorEmail()
    {
        // Lógica de envio de e-mail
    }
}
``` 

Aqui temos **três responsabilidades** misturadas:
1.  Geração do relatório. 
2.  Persistência.
3.  Comunicação (envio por e-mail).
    
## Exemplo refatorado

```csharp
public class RelatorioGenerator
{
    public void Gerar() { /* ... */ }
}
    
public class RelatorioRepository
{
    public void Salvar() { /* ... */ }
}
    
public class RelatorioEmailService
{
    public void Enviar() { /* ... */ }
}
``` 

Agora cada classe tem **um motivo único para mudar**, aplicando SRP.

# O - Open/Closed Principle (OCP)

## Definição
> "Entidades de software devem estar **abertas para extensão**, mas **fechadas para modificação**." — Bertrand Meyer

Isso significa que podemos **adicionar novos comportamentos sem alterar código existente**, evitando regressões.

## Problema comum
Uso de _if-else_ ou _switch_ para lidar com novos casos, exigindo alteração no código sempre que algo novo aparece.

## Exemplo ruim
```csharp
public class CalculadoraDesconto
{
    public decimal Calcular(string tipoCliente, decimal valor)
    {
        if (tipoCliente == "VIP") return valor * 0.1m;
        if (tipoCliente == "NOVO") return valor * 0.05m;
        return 0;
    }
}
```

## Exemplo refatorado
```csharp
public interface IDesconto
{
    decimal Calcular(decimal valor);
}
    
public class DescontoVip : IDesconto
{
    public decimal Calcular(decimal valor) => valor * 0.1m;
}
    
public class DescontoNovoCliente : IDesconto
{
    public decimal Calcular(decimal valor) => valor * 0.05m;
}
```

Agora é possível adicionar novos descontos **sem alterar** a lógica existente, apenas criando novas classes.

# L - Liskov Substitution Principle (LSP)

## Definição
> "Objetos de uma classe derivada devem poder substituir objetos da classe base **sem alterar o comportamento esperado**." — Barbara Liskov

## Problema comum
Criar subclasses que **quebram** funcionalidades esperadas da classe base.

## Exemplo ruim
```csharp
public class Pato
{
    public virtual void Voar() => Console.WriteLine("Voando...");
}
    
public class PatoDeBorracha : Pato
{
    public override void Voar() => throw new NotImplementedException();
}
```    

`PatoDeBorracha` viola o LSP porque não consegue voar, mas o código cliente espera que todo `Pato` possa voar.

## Exemplo refatorado
```csharp
public interface IAve { }
public interface IAveVoadora : IAve
{
    void Voar();
}
    
public class Pato : IAveVoadora
{
    public void Voar() => Console.WriteLine("Voando...");
}
    
public class PatoDeBorracha : IAve
{
    // Não voa, mas não viola expectativas.
}
```

A segregação de interfaces evita a quebra do LSP.

# I - Interface Segregation Principle (ISP)

## Definição
> "Nenhum cliente deve ser forçado a depender de métodos que não utiliza."

O ISP defende **interfaces menores e específicas**, em vez de interfaces grandes e genéricas.

## Problema comum

Interfaces que obrigam classes a implementar métodos irrelevantes.

## Exemplo ruim

```csharp
public interface IImpressora
{
    void Imprimir();
    void Escanear();
    void EnviarFax();
}
    
public class ImpressoraSimples : IImpressora
{
    public void Imprimir() { /* ok */ }
    public void Escanear() => throw new NotImplementedException();
    public void EnviarFax() => throw new NotImplementedException();
}
```    

## Exemplo refatorado

```csharp
public interface IImpressora
{
    void Imprimir();
}
    
public interface IScanner
{
    void Escanear();
}
   
public interface IFax
{
    void EnviarFax();
}
```

Agora cada classe implementa apenas o que precisa.

# D - Dependency Inversion Principle (DIP)

## Definição

> "Módulos de alto nível não devem depender de módulos de baixo nível; ambos devem depender de abstrações."

O DIP defende que classes devem depender de **interfaces** ou **classes abstratas**, não de implementações concretas.

## Problema comum

Acoplamento direto a classes concretas, dificultando substituição e testes.

## Exemplo ruim
```csharp
public class PedidoService
{
    private readonly PedidoRepository _repo = new PedidoRepository();
    
    public void Processar(Pedido pedido)
    {
        _repo.Salvar(pedido);
    }
}
```
    
## Exemplo refatorado
```csharp
public interface IPedidoRepository
{
    void Salvar(Pedido pedido);
}
    
public class PedidoService
{
    private readonly IPedidoRepository _repo;
    
    public PedidoService(IPedidoRepository repo)
    {
        _repo = repo;
    }
    
    public void Processar(Pedido pedido)
    {
        _repo.Salvar(pedido);
    }
}
```    

Agora é possível trocar a implementação de `IPedidoRepository` sem alterar `PedidoService`.

# Relação entre os princípios

Os cinco princípios trabalham juntos para produzir código:
*   Mais fácil de **testar**.
*   Mais simples de **modificar**.
*   Mais robusto contra **erros**.
*   Mais preparado para **mudanças de requisitos**.

## Check-list prático

Antes de finalizar uma funcionalidade, pergunte-se:

1.  **SRP**: Minha classe tem mais de uma responsabilidade?    
2.  **OCP**: Posso estender o comportamento sem alterar código existente?
3.  **LSP**: Substituir subclasses mantém o comportamento esperado?
4.  **ISP**: Minhas interfaces são pequenas e específicas?
5.  **DIP**: Estou dependendo de abstrações ou implementações concretas?