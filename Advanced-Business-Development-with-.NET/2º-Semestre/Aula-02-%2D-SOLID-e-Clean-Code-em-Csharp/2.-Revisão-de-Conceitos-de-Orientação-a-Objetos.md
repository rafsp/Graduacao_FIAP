[[_TOC_]]
    
Antes de entrarmos nos princípios **SOLID** e nas práticas de **Clean Code**, é essencial revisitar os **fundamentos da Programação Orientada a Objetos (POO)**.  
Afinal, SOLID é uma aplicação direta desses conceitos, e a compreensão incompleta da base compromete a aplicação correta das boas práticas.
    
# Abstração
    
## Conceito
A **abstração** consiste em modelar entidades do mundo real ou conceitos do domínio do problema em **representações de software**, ocultando detalhes irrelevantes e expondo apenas o que é essencial para o uso.
    
Em outras palavras, abstração é **criar um modelo simplificado** que destaca apenas as características importantes para o contexto.
    
## Exemplos do mundo real
- Ao dirigir um carro, você interage com o volante e o pedal do acelerador, mas não precisa conhecer cada detalhe do motor.
- Em um caixa eletrônico, o usuário interage com a interface para sacar dinheiro, sem entender como a comunicação bancária ocorre internamente.
    
## Exemplo em Csharp
    
```csharp
public abstract class Forma
{
    public abstract double CalcularArea();
}
    
public class Circulo : Forma
{
    public double Raio { get; set; }
    public override double CalcularArea() => Math.PI * Raio * Raio;
}
    
public class Retangulo : Forma
{
    public double Largura { get; set; }
    public double Altura { get; set; }
    public override double CalcularArea() => Largura * Altura;
}
```

O código acima **abstrai** o conceito de uma forma geométrica: cada forma sabe calcular sua própria área, mas o código que usa `Forma` não precisa conhecer os detalhes de cada cálculo.

# Encapsulamento

## Conceito

O **encapsulamento** é o princípio de **ocultar o estado interno de um objeto** e expor apenas métodos e propriedades seguras para interação.  
Isso evita que partes externas manipulem diretamente os dados internos, garantindo integridade e consistência.

## Por que é importante?

*   Protege dados contra modificações indevidas.
    
*   Reduz impacto de mudanças internas.
    
*   Mantém a consistência do estado do objeto.
    

## Exemplo em Csharp
```csharp
public class ContaBancaria
{
    private decimal saldo;
    
    public ContaBancaria(decimal saldoInicial)
    {
        saldo = saldoInicial;
    }
    
    public void Depositar(decimal valor)
    {
        if (valor <= 0) throw new ArgumentException("Valor inválido");
        saldo += valor;
    }
    
    public bool Sacar(decimal valor)
    {
        if (valor <= 0 || valor > saldo) return false;
        saldo -= valor;
        return true;
    }
    
    public decimal ConsultarSaldo() => saldo;
}
```

Aqui, `saldo` é **privado**, garantindo que só possa ser alterado por métodos que mantêm a lógica de negócio correta.

# Herança

## Conceito

A **herança** permite que uma classe (_subclasse_) reutilize e estenda funcionalidades de outra classe (_superclasse_).  
Essa relação é conhecida como **"é um"** (_is a_).

## Cuidados

*   Use herança apenas quando houver **verdadeira relação hierárquica**.
    
*   Evite heranças profundas e complexas (dificultam manutenção).
    
*   Prefira **composição** quando a relação não for estritamente "é um".
    

## Exemplo em Csharp
```csharp
public class Veiculo
{
    public string Marca { get; set; }
    public void Acelerar() => Console.WriteLine("Acelerando...");
}
    
public class Carro : Veiculo
{
    public int NumeroDePortas { get; set; }
}
    
public class Moto : Veiculo
{
    public bool TemSidecar { get; set; }
}
``` 

`Carro` e `Moto` **herdam** de `Veiculo` e, portanto, possuem a propriedade `Marca` e o método `Acelerar`.

# Polimorfismo

## Conceito

O **polimorfismo** permite que um mesmo método ou interface tenha comportamentos diferentes dependendo do objeto que o implementa.  
Ele é a chave para escrever código **flexível** e **extensível**.

## Tipos
*   **Polimorfismo de sobrescrita** (_override_): redefinição de métodos em classes derivadas.
*   **Polimorfismo de sobrecarga** (_overload_): múltiplas versões de um método com assinaturas diferentes.

## Exemplo de sobrescrita
```csharp
public abstract class Animal
{
    public abstract void EmitirSom();
}
    
public class Cachorro : Animal
{
    public override void EmitirSom() => Console.WriteLine("Au au!");
}
    
public class Gato : Animal
{
    public override void EmitirSom() => Console.WriteLine("Miau!");
}
    
// Uso
Animal a1 = new Cachorro();
Animal a2 = new Gato();
    
a1.EmitirSom(); // Au au!
a2.EmitirSom(); // Miau!
``` 

# Relação entre POO e SOLID

Os conceitos de POO são o **terreno fértil** onde o SOLID é aplicado:
| Conceito POO | Relação com SOLID |
| --- | --- |
| **Abstração** | Base para OCP, ISP e DIP (trabalhar com interfaces e classes abstratas). |
| **Encapsulamento** | Apoia SRP e ISP, mantendo responsabilidades separadas e protegendo dados. |
| **Herança** | Relaciona-se ao LSP; usada corretamente, permite substituição segura. |
| **Polimorfismo** | Fundamental para OCP e DIP, possibilitando comportamentos dinâmicos. |

# Erros comuns ao aplicar POO

1.  **God Classes**  
    Classes gigantes com múltiplas responsabilidades, dificultando manutenção.
    
2.  **Abstrações prematuras**  
    Criar interfaces e classes genéricas antes da real necessidade, aumentando complexidade.
    
3.  **Herança inadequada**  
    Forçar relação "é um" quando a correta seria "tem um" (composição).
    
4.  **Acoplamento excessivo**  
    Depender fortemente de implementações concretas, quebrando DIP.
    

# Conclusão da Revisão

A POO fornece as **ferramentas conceituais** para criar sistemas modulares e reutilizáveis.  
Os princípios SOLID são **refinamentos práticos** desses conceitos para garantir manutenibilidade e escalabilidade.
Na próxima seção, exploraremos cada princípio SOLID em detalhe, conectando teoria e prática no contexto de C# e .NET.